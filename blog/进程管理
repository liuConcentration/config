#include<unistd.h>
#include<sys/types.h> 

创建一个进程 以下函数 定义在 unisted.h 中，pid_t 定义在 sys/types.h 中
pid_t fork(void);
pid_t vfork(void);
int __clone();

以上两个函数的 区别：
1.fork 子进程  会复制 父进程的 堆栈信息，vfork再执行exit和execl前与父进程的数据是共享的,所谓共享就是说，没有开辟新的物理内存。
2.vfork 总是 先执行子进程，而fork不确定
3.执行vfork后 父进程 处于挂起状态，知道子进程执行exit或者execl为止


执行新的程序：
多参数 以NULL结尾
argv 必须 存在一个 因为 默认 main 的 argv函数的 地一个 参数 为 所执行的 程序名
int execl(const char * filename, char *argv,...)      在目录中查找程序
int execlp(const char * filename, char *argv,...)     在环境变量中超找程序
int execle(const char * filename, char *argv,..., char* const envp[]) 在envp执行的 环境变量中超找程序
多参数村才在 字符数组中，以NULL结尾
int execv(const char * filename, char *const argv[])
int execvp(const char * filename, char *const argv[])
int execve(const char * filename, char *const argv[],char* const envp[])


僵尸进程，进程的等待:
当程序 fork一个 子进程后，如果子进程结束，会向父进程发送一个SIGCHLD 信号，告诉父进程子进程结束的状态信息，时间信息等，父进程接收处理之前，子进程并没有结束，这时这个子进程就是僵尸进程。
解决这个问题可以用以下4种方法：
1、父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。
2. 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。
3. 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD, SIG_IGN） 通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。
4. 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收 还要自己做。

pid_t wait(int *status);
pid_t waitid(pid_t pid, int *status, int options);


